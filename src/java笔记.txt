

java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,

另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值在-128到+127时才可使用对象池，

也即对象不负责创建和管理大于127的这些类的对象。



Arraylist构造一个无参的构造方法时，默认分配的大小是10，当不够用时增加0.5倍

Arraylist的特点是查询快，增删慢。因为数组的内存地址是连续的，所以可以通过指针的移位快速的访问到数组中的数据。增加慢的原因是当数组的空间不够用时，增加

新的数据时，这时会重新开辟一个1.5倍大小的数据，然后将旧数据拷贝到新的数组中

vector是线程安全的，操作效率低

vector与Arraylist底层都是利用的对象数组

vector线程同步，操作效率低，Arraylist线程不同步，操作效率高

Arraylist是jdk1.2出现的，vector是jdk1.0出现的



java虚拟机的作用：解释class文件并通知系统要执行哪些操作



设置classpath环境变量信息的有分号与没有分号 的区别：	

		

		1. 如果配置classpath环境变量信息没有加上分号,那么java虚拟机仅会在classpath所保存的路径下去搜索对应的class文件，不会在当前路径下去搜索了。



		2. 如果配置classpath环境变量信息加上分号，那么java虚拟机除了会在classpath所保存的路径下去搜索对应 的class文件之外,如果能找到对应的class文件

		那么就马上指定对应的class文件，否则还会去 当前路径下去搜索。



javac：启动java编译器对指定的java源文件进行编译

java:启动java虚拟机解释并执行对应的class文件



java中的数据类型

基本数据类型

引用数据类型

java中的八种数据类型

整数的数据类型

byte(字节)	1字节	8位	2^8=256		-2^7(-128)~2^7-1(127)

short(短整型)	2字节	16位	2^16=65536	-2^15~2^15-1

int(整型)	4字节	32位	2^32		-2^31~2^31-1

long(长整型)	8字节	64位	2^64		-2^63~2^63-1

小数数据类型

float(单精度浮点型)	4字节	32 位	可以精确到小数点7位

double(双精度浮点型)	8字节	64位	可以精确到小数点后15位

布尔类型

boolean 在内存中占1字节或者4字节

如果使用boolean声明一个基本类型的变量时，那么该变量占4字节

如果使用boolean声明一个数组类型时，那么每个数组中的元素占一个字节

字符

char 2字节	16位

数据类型转换要注意的细节

1、凡是byte、short、char数据类型数据在运算的时候都会自动转换成int类型的数据再运算

	byte b1=1;

	byte b2=2;

	byte c=(byte) (b1+b2);

2、两个不同的数据类型在运算的时候，结果取决于大的数据类型

3、byte b=10//一个整数在没有加上任何标识的时候，默认是int类型的数据。10是一个常量，编译器在编译的时候就能够确定它的值了，byte b=10在编译的时候编译器

检查到10并没有超出byte的表示范围，允许赋值。

int i=10;byte b=i;//出错。java编译器在编译的时候，并不能确认变量所存储的值，变量存储的值是在运行的时候才在内存中分配的

使用异或交换两个变量

int a=3;

int b=5;

a=a^b;

b=a^b;

a=a^b;

使用加减法交换变量//缺点可能会出现超出int的表示范围

int a=3;

int b=5;

a=a+b;

b=a-b;

b=a-b



移位操作

>>右移

如果移位操作数是正数，则左边用0来补，如果移位数是负数则用1来补

<<左移

>>>无符号右移

无论移位数是正数还是负数都统一用0来补





java虚拟机中的内存：栈内存、堆内存

栈内存的特点：栈内存存储的都是局部变量，变量一旦出了自己的作用域，那么马上会从内存中消失。释放内存空间。（基本类型的数值以及类的实例）

堆内存的特点：堆内存存储的都是对象数据，对象一旦被使用完，并不会马上从内存中消失，而是等待垃圾回收器不定时把垃圾对象回收，这时候该对象才会消失，释放内存。


Arrays.sort()

对基本类型用的快速排序，对对象类型是归并排序。

原因可能和稳定性有关。

一般来说，快速排序效率最高，不过快速排序是不稳定的，就是比如说数组中的值相同的两个整数，排序前和排序的先后顺序可能不一致，这对基本类型来说是完全可以接受的。

但对对象类型来说，用户可能有稳定性方面的要求，于是使用了效率和稳定都能兼顾的归并排序。



成员属性有默认的初始值，局部变量没有默认初始值，必须要先初始化才能使用



java反编译工具的使用格式 javap -c -l -private 类名





构造函数的作用：给对应的对象进行初始化

如果一个类没有显示的写上一个构造方法时，那么java编译器会为该类添加一个无参的构造函数

java编译器添加的无参构造方法的权限修饰符是与类的权限修饰符保持一致的



构造代码块的格式：
{
	代码块
}

构造代码块的作用：给对象进行统一初始化

构造函数的作用：给对应对象进行初始化



代码块的类别

构造代码块

局部代码块，大括号位于方法之内。作用：缩短局部变量的生命周期，节省一点点内存

静态代码块





public class Test {

	

	{

		i=2;

	}

	int i=1;

	

	public static void main(String[] args) {

		System.out.println(new Test().i);//结果为：1

	}



}

1、java编译器编译一个java源文件的时候，会把成员变量的声明语句提前至一个类的最前端

2、成员变量的初始化工作其实都在构造函数中执行的

3、一旦经过java编译器编译后，那么构造代码块中的代码块就会被移动到构造函数中执行，构造函数中的代码最后执行。

4、构造代码块中的代码与成员变量的显示赋值的顺序是根据代码中的先后顺序执行的。





一个方法要运行的时候，jvm会在栈内存中开辟一片属于这个方法的空间。让这个方法在这片空间中执行

this关键字代表了所属函数的调用者对象

如果存在同名的局部变量与成员变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据

如果在一个方法中访问了一个和成员变量重名的变量，则java编译器会在该变量的前面加上this关键字



在一个构造函数中可以调用另外一个构造函数初始化对象

this关键字调用其他构造函数时需要注意的事项

1、this关键字调用其他的构造函数时，this关键字必须要位于构造函数中的第一个语句

2、this关键字在构造函数中不能出现相互调用的情况，因为是一个死循环



static静态修饰符

1、static修饰成员变量：如果有数据需要被共享给所有对象使用，那么就可以使用static修饰

静态成员变量的访问

方式1、对象.变量名

方式2、类名.变量名

非静态的成员变量只能使用对象进行访问，不能使用类名进行访问

静态函数不能出现this或者super关键字

静态代码块是在类class文件加载到内存时就开始执行

静态函数不能    直接   访问非静态成员



静态成员变量是优先于对象存在的



静态方法不能直接访问非静态成员（非静态成员方法与非静态成员变量）

静态方法不能直接访问非静态成员变量：由于静态方法可以直接通过类名进行调用，而在此时非静态的成员变量并不存在，非静态的成员变量是在对象创建的时候才存在的

静态方法不能直接方法非静态成员函数：由于非静态成员函数可以直接访问非静态的成员变量，此时非静态成员变量并不存在。

非静态方法既可以直接访问非静态成员也可以直接访问静态成员

静态函数内有对象也可以访问非静态的成员变量，只是不能直接访问



静态成员变量与非静态成员变量的区别

1、作用上的区别

	1.静态成员变量的作用共享一个数据给所有对象使用

	2.非静态成员变量的作用是描述一类事物的公共属性

2、数量与存储位置上的区别

	1.静态成员变量存在于方法区内存中，而且只会保存一份

	2.非静态的成员变量是存在于堆内存中的，有n个对象就会有n份数据

3、生命周期的区别

	1.静态的成员数据是随着类的加载而存在，随类文件的消失而消失

	2.非静态的成员是随着对象的创建而存在，随着对象被垃圾回收器回收而消失



main函数详解



public 公共的，权限最大，让jvm在任何情况下都能够访问到main函数

static 静态可以使jvm调用main函数的时候更加的方便，不需要通过对象调用。

不使用静态方法的麻烦

1.需要创建对象调用

2.jvm不知道如何创建对象，因为创建对象需要参数的，jvm不知道如何设置参数





单例模式

模式：就是解决一类问题的固定模式

软件行业中有23种设计模式

单例设计模式

模板设计模式

装饰者设计模式

观察者设计模式

工厂设计模式
单例设计模式：保证一个类在内存中只有一个对象

设计单例模式的步骤

饿汉单例设计模式

1、私有化构造方法

2、声明本类的引用类型变量，并且使用该变量指向本类对象

3、提供一个公共的静态方法获取本类的对象



//饿汉单例设计模式 ----> 保证Single在在内存中只有一个对象。

class Single{



	//声明本类的引用类型变量，并且使用该变量指向本类对象

	private static	Single s = new Single();



	//私有化构造函数

	private Single(){}



	//提供一个公共静态的方法获取本类的对象

	public	static  Single getInstance(){

		return s;

	}

}



class Test{

public static Test t=new Test();

private Test{}

public static Test getInstance(){

return t;

}

}

class Test{

public static Test t;

private Test{}

public static Test getInstance(){

if(t==null){

t=new Test();

}

return t;

}

}



懒汉单例设计模式：

	1. 私有化构造函数。

	2. 声明本类的引用类型变量，但是不要创建对象，

	3. 提供公共静态 的方法获取本类 的对象，获取之前先判断是否已经创建了本类 对象

	，如果已经创建了，那么直接返回对象即可，如果还没有创建，那么先创建本类的对象，

	然后再返回。

//懒汉单例设计模式 ----> 保证Single在在内存中只有一个对象。



class Single2{

	

	//声明本类的引用类型变量，不创建本类的对象

	private static Single2 s;



	//私有化了构造函数

	private Single2(){}



	//

	public static Single2 getInstance(){

		if(s==null){

			s = new Single2();

		}

		return s;

	}

}

推荐使用： 饿汉单例设计模式。  因为懒汉单例设计模式会存在线程安全问题，目前还不能保证一类在内存中只有一个对象。

面向对象的三大特征：

	1. 封装

	2. 继承

	3. 多态.



继承：继承是通过关键字extends体现的。





继承要注意的事项：

	1. 千万不要为了减少重复代码而去继承，只有真正存在着继承关系的时候才去继承。

	2. 父类私有的成员不能被继承。

	3. 父类的构造函数不能被继承。

	4. 创建子类对象时默认会先调用父类无参的构造函数。
在类继承中，方法分为覆盖和隐藏，而类中的变量则都是隐藏的，即变量（不管是静态变量还是普通变量）都是跟类绑定的。
如果子类中定义了静态方法，则它会隐藏父类中形构相同的所有方法



创建子类对象时首先会调用父类的构造方法，当在子类的构造方法中没有显示的用super关键字调用父类的构造方法时，子类此时默认调用父类的无参数的构造

方法，如果父类不存在无参数的构造方法则会报错。



疑问： 为什么要调用父类的构造方法啊？这样子做的意义在那？



	调用父类 的构造方法是可以初始化从父类继承下去的属性的。



super关键字代表了父类空间的引用。



super关键字的 作用：

	1. 子父类存在着同名的成员时，在子类中默认是访问子类的成员，可以通过super关键字指定访问父类的成员。

	2. 创建子类对象时，默认会先调用父类无参的构造方法，可以通过super关键字指定调用父类的构造方法。



super关键字调用父类构造方法要注意的事项：

	1. 如果在子类的构造方法上没有指定调用父类的构造方法，那么java编译器会在子类的构造方法上面加上super()语句。

	2. super关键字调用父类的构造函数时，该语句必须要是子类构造函数中的第一个语句。

	3. super与this关键字不能同时出现在同一个构造函数中调用其他的构造函数。因为两个语句都需要第一个语句。注意不是说super关键字与this关键字不能同时出现在一个构造函数中。

super关键字与this关键字的区别：

	1. 代表的事物不一致。

			1. super关键字代表的是父类空间的引用。	

			2. this关键字代表的是所属函数的调用者对象。

	2. 使用前提不一致。

			1. super关键字必须要有继承关系才能使用。

			2. this关键字不需要存在继承关系也可使用。

	3. 调用构造函数的区别：

			1. super关键字是调用父类的构造函数。

			2. this关键字是调用本类的构造函数。



目前的问题：父类的功能无法满足子类的需求。



方法重写的前提： 必须要存在继承的关系。



方法的重写: 子父类出现了同名的函数，这个我们就称作为方法的重写。



什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。

方法重写要注意的事项：

	1.方法重写时， 方法名与形参列表必须一致。

	2.方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符。

	3.方法重写时，子类的返回值类型必须要小于或者 等于父类的返回值类型。

	4.方法重写时， 子类抛出的异常类型要小于或者等于父类抛出的异常类型。

			Exception(最坏)

			RuntimeException(小坏)
方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。



方法重载的要求

	1. 函数名要一致。

	2. 形参列表不一致（形参的个数或形参 的类型不一致）

	3. 与返回值类型无关。
final关键字的用法：

	1. final关键字修饰一个基本类型的变量时，该变量不能重新赋值，第一次的值为最终的。

	2. fianl关键字修饰一个引用类型变量时，该变量不能重新指向新的对象。

	3. final关键字修饰一个函数的时候，该函数不能被重写。

	4. final关键字修饰一个类的时候，该类不能被继承。

常量 的修饰符一般为： public static final 

抽象类要注意的细节：

	1. 如果一个函数没有方法体，那么该函数必须要使用abstract修饰,把该函数修饰成抽象 的函数。。

	2. 如果一个类出现了抽象的函数，那么该类也必须 使用abstract修饰。

	3. 如果一个非抽象类继承了抽象类，那么必须要把抽象类的所有抽象方法全部实现。

	4. 抽象类可以存在非抽象方法，也可以存在抽象的方法.

	5. 抽象类可以不存在抽象方法的。 

	5. 抽象类是不能创建对象的。

		疑问：为什么抽象类不能创建对象呢？

		因为抽象类是存在抽象方法的，如果能让抽象类创建对象的话，那么使用抽象的对象

		调用抽象方法是没有任何意义的。

	6. 抽象类是存在构造函数的，其构造函数是提供给子类创建对象的时候初始化父类的属性的。



abstract不能与以下关键字共同修饰一个方法：

	1. abstract不能与private共同修饰一个方法。

	private修饰的方法，子类不可见，而abstract修饰的方法又让子类去实现，这样就产生了矛盾。

	2. abstract 不能与static共同修饰一个方法。

	如果一个方法是static修饰的，则可以通过类名去调用，如果该方法又被abstract所修饰，该方法又是一个抽象的方法。这样去直接调用一个抽象的方法是没有意义的。

	3. abstract 不能与final共同修饰一个方法。

	final所修饰的方法子类不能重写，abstract又让子类实现抽象的方法，产生了矛盾

一个类最多只能有一个直接的父类。但是有多个间接的父类。





接口要注意的事项 ：

	1. 接口是一个特殊的类。

	2. 接口的成员变量默认的修饰符为： public static final 。那么也就是说接口中的成员变量都是常量。

	3. 接口中 的方法都是抽象的方法，默认的修饰符为： public abstract。

	4. 接口不能创建对象。

	5. 接口是没有构造方法的。

	6. 接口是给类去实现使用的，非抽象类实现一个接口的时候，必须要把接口中所有方法全部实现。



类与接口之间关系： 实现关系。



类与接口要注意的事项：

	1. 非抽象类实现一个接口时，必须要把接口中所有方法全部实现。

	2. 抽象类实现一个接口时，可以实现也可以不实现接口中的 方法。

	3. 一个类可以实现多个接口 。

接口与接口之间关系： 继承关系。



接口与接口之间要注意事项：

	1. 一个接口是可以继承多个接口的。



多态：一个对象具有多种形态。父类的引用类型变量指向了子类的对象，或者是接口的引用类型变量指向的接口实现类的对象



多态要注意 的细节：

	1.  多态情况下，子父类存在同名的成员变量时，访问的是父类的成员变量。

	2.  多态情况下，子父类存在同名的非静态的成员函数时，访问的是子类的成员函数。

	3.  多态情况下，子父类存在同名的静态的成员函数时，访问的是父类的成员函数。



	4.  多态情况下，不能访问子类特有的成员。

	若想访问子类特有的成员需要进行强制类型转换

	接口调用的都是接口实现类的方法是因为接口里的方法都是非静态的。



总结：多态情况下，子父类存在同名的成员时，访问的都是父类的成员，除了在同名非静态函数时才是访问子类的。



编译看左边，运行不一定看右边。



编译看左边：java编译器在编译的时候，会检查引用类型变量所属的类是否具备指定的成员，如果不具备马上编译报错。





内部类：

成员内部类与局部内部类



成员内部类的访问方式

1、在外部类提供一个方法创建一个内部类对象进行访问

2、在其他类直接创建内部类对象 格式：外部类.内部类 变量名=new 外部类().new 内部类()



内部类可以直接访问外部类的所有成员



内部类的应用场景：我们在描述一件事物A的时候，发现事物A的内部存在着一件比较复杂的事物B，而且事物B需要用到事物A的属性，这个时候我们可以用内部类描述事物B

在内部类与外部类存在同名的成员变量时，默认访问的是内部类的成员变量，要想访问外部类的成员函数可以使用 “外部类.this.成员变量”进行访问

成员内部类一旦出现了静态的成员，那么该成员内部类也必须用static修饰

原因：静态的成员数据是不需要对象的存在才能访问的，如果当成员内部类定义了静态的成员，而成员内部类没有用static修饰的时候，这时候只有在内部类对象存在的时候才能够访问该静态成员数据，这与静态成员的设计初衷相矛盾。



静态内部类的创建格式：外部类.内部类 变量名=new 外部类.内部类();



如果局部内部类访问了一个局部变量，那么该局部变量一定要用final修饰。

原因：局部变量的生命周期是当方法执行完毕之后就立刻消失，而对象的消失是在垃圾回收器进行回收的时候才消失，
这个时候如果内部类中访问了局部变量就存在了一个对象访问了一个不存在的局部变量的问题，
为了解决这个问题jvm就复杂了一份局部变量用于内部类进行访问，这个时候就需要让这个局部变量为final类型的。

匿名内部类：没有类名的类叫做匿名内部类

匿名内部类的使用前提必须存在继承或者实现关系才能使用

匿名内部类不能出现特有的方法

在使用匿名内部类时，要记住以下几个原则：


　　　　　　a·匿名内部类不能有构造方法。
		没有名字
　　　　　　b·匿名内部类不能定义任何静态成员、方法和类。
　　　　　　c·匿名内部类不能是public,protected,private,static。
　　　　　　d·只能创建匿名内部类的一个实例。
　　　　　　e·一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
　　　　　　f·因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。

java虚拟机在默认的情况下只能管理64m的内存

错误一般是由于jvm引发的问题，或者是硬件的问题，所以我们一般不会通过代码去处理

异常时需要通过代码去处理的



异常的体系：

----------| Throwable  所有异常或者错误类的超类

--------------|Error  错误   错误一般是用于jvm或者是硬件引发的问题，所以我们一般不会通过代码去处理错误的。

--------------|Exception 异常   是需要通过代码去处理的。

异常：运行时异常：如果一个方法内部抛出了一个运行时异常，那么方法上可以声明也可以不声明，调用者可以处理也可以不处理。
	因为运行时异常都是可以程序员良好的编程习惯来避免发生的

      编译时异常：如果一个方法内部抛出了一个编译时异常，那么方法上必须声明，调用者必须处理。

      运行时异常：RuntimeException以及RuntimeException的子类都是运行时异常

      编译时异常：除了运行时异常之外的异常



如何区分错误与异常呢：

	如果程序出现了不正常的信息，如果不正常的信息的类名是以Error结尾的，那么肯定是一个错误。

	如果是以Exception结尾的，那么肯定就是一个异常。



模板模式的步骤：

	1. 先写出解决该类事情其中 的一件的解决方案。

	2. 分析代码，把会发生变化的代码抽取出来独立成一个方法。把该方法描述成一个抽象的方法。

	3. 使用final修饰模板方法，防止别人 重写你的模板方法。



一个java应用程序至少有两个线程，一个是main方法的线程一个是垃圾回收器线程负责回收垃圾

静态变量、成员变量都是线程非安全的，局部变量是线程安全的



多线程的好处：

1、解决了一个进程同时执行多个任务的问题

2、提高了资源的利用率



多线程的弊端：

1、增加了cpu的负担

2、降低了一个进程中线程的执行概率

3、引发了线程安全问题

4、出现了死锁现象

sleep()方法是静态方法，哪部分代码调用就是哪个线程睡眠

优先级的范围是1~10
什么情况下才可能出现线程安全

1、存在两个或者两个以上的线程

2、多个线程操作了共享资源



解决多线程的方法

方法以：同步代码块

同步代码块格式

synchronized(锁对象){



	需要被同步大代码



}



同步代码块要注意的事项

1.锁对象可以是任意的一个对象

原因：凡是对象内部都维护了一个状态，java的同步机制就利用了对象的状态来作为锁的标识。

在同步代码块中调用了sleep()方法，并不会释放锁对象

多线程操作的锁对象必须是唯一共享的，否则无效

同步函数要注意的事项：

1、如果是一个非静态的同步函数的锁 那么对象是this对象，如果是静态的同步函数的锁 那么对象是当前函数所属类的字节码文件(class 对象)

2、同步函数的锁对象是固定的





java中同步机制解决了线程安全问题，但是也同时引发了死锁现象



死锁现象出现的根本原因：

1、存在两个或者两个以上的线程

2、存在两个或者两个以上的共享资源



Runnable实现类的对象并不是一个线程对象，只不过是实现了Runnable接口的对象而已

只有是Thread或者Thread的子类才是线程对象



为什么要把Runnable实现类的对象作为实参传递给Thread对象呢？作用是什么？

作用就是把Runnable实现类的对象的run方法作为了线程的任务代码去执行了





wait与notify方法要注意的事项

1、wait方法与notify方法是属于object对象的

2、wait方法与notify方法必须要在同步代码块或者是同步函数中才能使用

3、wait方法与notify方法必须要由锁对象调用


wait():一个线程如果执行了wait方法，那么该线程就会进去一个以锁对象为标识符的线程池中等待。

notify():如果一个线程执行了notify方法，那么就会唤醒以锁对象为标识符的线程池中的其中一个等待线程。



interrupt()方法不需要由锁对象去调用，把线程的等待状态强制清除，被清除状态的线程会接收到一个interruptedExcepthon,可以指定清除哪个线程的等待状态。

同时被清除了等待状态的线程会收到一个异常的。



一般停止一个线程我们都会通过一个变量去控制等待



线程的停止

1、停止一个线程我们一般都会通过一个变量去控制的

2、如果需要停止一个等待状态下的线程，我们需要通过变量配合notify方法或者interrupt方法
setDaemon()设置线程是否为守护线程，一个线程默认都不是守护线程
在一个进程中如果只剩下了守护线程，那么守护线程也会死亡
一个线程如果执行了join语句，那么就有新的线程加入，执行该语句的线程必须要让步给新加入的线程完成任务，然后才能继续执行



对象克隆要注意的细节

1、如果一个对象要调用clone的方法克隆，那么该对象所属的类必须要实现cloneable接口

2、cloneable接口只不过是一个标识接口而已，没有任何方法

3、对象的浅克隆就是克隆一个对象的时候，如果被克隆的对象中维护了另外一个类的对象，这时候只是克隆另外一个对象的地址，而没有把另外一个对象也克隆一份。



观察者设计模式：观察者设计模式解决的问题是当一个对象发生指定的动作时，要通知另外一个对象做出相应的处理。



观察者设计模式的步骤

1、当目前对象发生指定的动作时，要通知另外一个对象做出相应的处理，这时候应该把对方的相应处理方法定义在接口上。

2、在当前对象维护接口的引用，当当前对象发生指定的动作这时候既可调用接口中的方法了



java中的i++与++i

i++,是jvm先把i的值放在临时变量区，然后i自增1，最后再把临时变量区的值交给i

++i,没有临时变量区，等同于i=i+1


-------------------网络资料----------------------
堆内存设置
原理
JVM堆内存分为2块：Permanent Space（又叫方法区） 和 Heap Space。
Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。
Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。
年轻代
所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。

大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。

2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。

针对年轻代的垃圾回收即 Young GC。

年老代
在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

针对年老代的垃圾回收即 Full GC。

我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。

持久代
用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。
所以，当一组对象生成时，内存申请过程如下：

JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。
当Eden区空间足够时，内存申请结束。否则执行下一步。
JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。
Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。
当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。
Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。
OOM（“Out of Memory”）异常一般主要有如下2种原因：

1. 年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace
这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。
例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。

2. 持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace
通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。

short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
如果你认为表达式（x += i）只是表达式（x = x + i）的简写方式，这并不准确。
这两个表达式都被称为赋值表达式。（x = x + i）表达式使用的是简单赋值操作符（=），而（x += i）表达式使用的是复合赋值操作符。Java语言规范中讲到，复合赋值（E1 op=E2）等价于简单赋值（E1=(T)((E1) op (E2))），其中T是E1的类型，除非E1只被计算一次。   换句话说，复合赋值表达式自动地将所执行计算的结果转型为其左侧变量的类型。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。然而，如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原生类型转换。  
【e1+=e2    实际上是    e1=(T1)(e1+e2) 】，其中T1是e1的数据类型。   s1+=1等效于   s1=(short)(s1+1),所以是正确的。

abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized
static声明的方法是可以通过类直接访问的，如果abstract可以和static同时用的话也就意味着可以直接访问抽象方法，这是没有意义的。
native声明的方法标明具体的实现交给本地操作系统，而用abstract声明的方法标明具体的实现交给子类，这就发生了冲突
用synchronized的前提是该方法可以被直接调用，显然不能和abstract连用

JDK的动态代理是靠多态和反射来实现的，它生成的代理类需要实现你传入的接口，并通过反射来得到接口的方法对象（下文中的m3），并将此方法对象传参给增强类（上文中的WavingInvocationHandler类）的invoke方法去执行，从而实现了代理功能，故接口是jdk动态代理的核心实现方式，没有它就无法通过反射找到方法，所以这也是必须有接口的原因



Innodb引擎

Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，关于数据库事务与其隔离级别的内容请见数据库事务与其隔离级别这篇文章。该引擎还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。

MyIASM引擎

MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。

两种引擎的选择

大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题，关于这个问题我会在下文中讲到。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。

 事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位

 针对上面的描述可以看出，事务的提出主要是为了解决并发情况下保持数据一致性的问题。

 事务具有以下4个基本特征。
 ①原子性(Atomicity)：事务中的所有元素作为一个整体提交或回滚，事务的每个元素是不可分的，事务是一个完整操作。
 ②一致性(Consistemcy)：事务完成时，数据必须是一致的，也就是说，和事务开始之前，数据存储中的数据处于一致状态。保证数据的无损。
 ③隔离性(Isolation)：对数据进行修改的多个事务是彼此隔离的。这表明事务必须是独立的，不应该以任何方式依赖于或影响其他事务。
 ④持久性(Durability)：事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留，真实的修改了数据库


 
事务的传播行为
PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 
PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。 
PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。 
PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起。 
PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常。
PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。

Propagation.REQUIRED
指定当前的方法必须在事务的环境下执行；
		如果当前运行的方法，已经存在事务， 就会加入当前的事务；
Propagation.REQUIRED_NEW
		指定当前的方法必须在事务的环境下执行；
如果当前运行的方法，已经存在事务：  事务会挂起； 会始终开启一个新的事务，执行完后；  刚才挂起的事务才继续运行。

PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 "内部" 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行. 
另一方面, PROPAGATION_NESTED 开始一个 "嵌套的" 事务,  它是已经存在事务的一个真正的子事务. 潜套事务开始执行时,  它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. 
由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 潜套事务也会被 commit, 这个规则同样适用于 roll back.


 cookie与session的区别
cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。
session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。
虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。
如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：URL地址重写。
URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(String url)实现URL地址重写，该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。
注意：TOMCAT判断客户端浏览器是否支持Cookie的依据是请求中是否含有Cookie。尽管客户端可能会支持Cookie，但是由于第一次请求时不会携带任何Cookie（因为并无任何Cookie可以携带），URL地址重写后的地址中仍然会带有jsessionid。当第二次访问时服务器已经在浏览器中写入Cookie了，因此URL地址重写后的地址中就不会带有jsessionid了。

redict与forward的区别
redict 是服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。它本质上是两次HTTP请求，对应两个request对象。
forward客户端浏览器只发出一次请求，服务器把请求转发给其它信息资源，由第2个信息资源响应该请求，两个信息资源共享同一个request对象

内存溢出与内存泄漏的区别
内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用。
内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。
那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。具体主要有如下几大类： 
1、静态集合类引起内存泄露： 
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。
2、各种连接 
比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。
3、单例模式
不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露

如下几种情况，jvm将结束生命周期
1、执行了System.exit()方法
2、程序正常执行结束
3、程序在执行过程中遇到了异常或错误而异常终止
4、由于操作系统出现错误而导致jvm进程终止

类加载过程
加载：查找并加载类的二进制数据
链接：
1、验证：确保被加载的类的正确性
2、准备：为类的静态变量分配内存，并将其初始化为默认值
3、解析：把类中的符号引用转换为直接引用
初始化：为类的静态变量赋予正确的初始值

java程序对类的使用方式分为两种
1、主动使用
2、被动使用
所有的jvm实现必须在每个类或接口被java程序“首次使用”时才初始化他们

主动使用（六种）
1、创建类的实例
2、访问某各类或接口的静态变量，或者对该静态变量赋值
3、调用类的静态方法
4、反射
5、初始化一个类的子类
6、jvm启动时被标明为启动类的类
除了以上六种情况，其他使用java类的方式都被看做是对类的被动引用，都不会导致类的初始化

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后再堆区创建一个Class对象，用来封装类在方法区内的数据结构。

加载.class文件的方式
–从本地系统中直接加载
–通过网络下载.class文件
–从zip，jar等归档文件中加载.class文件
–从专有数据库中提取.class文件
–将Java源文件动态编译为.class文件

类的加载的最终产品是位于堆区中的Class对象
•Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口

有两种类型的类加载器
–Java虚拟机自带的加载器
•根类加载器（Bootstrap）
•扩展类加载器（Extension）
•系统类加载器（System）
–用户自定义的类加载器
•java.lang.ClassLoader的子类
•用户可以定制类的加载方式

类加载器并不需要等到某个类被“首次主动使用”时再加载它


jvm运行时数据区
1、程序计数器：是一块较小的内存，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条
需要执行的字节码指令。为了每个线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。如果线程正在执行的是一个java方法，这个计数器
记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空，此内存区域是唯一一个在java虚拟机规范中没有规定任何outofmemoryerror
情况的区域。
2、java虚拟机栈
java虚拟机栈也是线程私有的，它的生命周期与线程相同，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被
调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。局部变量表存放了编译期可知的各种基本数据类型、对象引用类型和返回类型。
其中64位长度的double和long类型的数据会占用2个局部变量空间(slot)，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个
方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。java虚拟机栈中对这块区域规定了两种异常情况：如果线程请求的栈深度
大于虚拟机所允许的深度，将抛出StackOverflowError异常；当扩展时无法申请到足够的内存将会抛出OutOfMemoryError异常。
栈帧是方法运行时的基础数据结构
3、本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则是为虚拟机使用到的native方法服务。与虚拟机栈一样，
本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
4、java堆
java堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例
都在这里分配内存。java堆还可以细分为新生代（Eden区，from survivor区，to survivor区）。堆扩展可以通过（-Xmx和-Xms控制）。如果堆中没有内存完成实例分配，并且堆
也无法再扩展时，将会抛出OutOfMemoryError。
5、方法区
方法区与java堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量。静态变量、即时编译器编译后的代码等。习惯上也把这部分区域叫做永久代
这个区域的垃圾收集行为很少出现，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError.
6、运行时常量池
运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还要一项信息时常量池。用于存在编译期生成的各种字面量和符号引用。
这部分内容将在类加载后存在在方法区中的常量池中。运行时常量池相对应Class文件常量池的另外一个重要特征是具备动态性，java语言并不要求常量一定只能在编译期产生，
运行期间也可能将新的常量放在池中，这种特性被开发人员用的比较多的是String类和intern()方法。
当常量池无法再申请到内存时将会抛出OutOfMemoryError异常。

判断对象是否存活的算法
1、引用计数方法2、根搜索方法
跟搜索算法：当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达的。
可以作为GCRoot的对象包括以下几种
1、虚拟机栈中的引用的对象
2、方法区中的类静态属性引用的对象
3、方法区中的常量引用的对象
4、本地方法栈中GNI的引用对象


回收算法
永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。
需要同时满足一下三个条件才能算是“无用的类”
1、该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例。
2、改类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
3、加载该类的类加载器已经被回收


回收策略
1、标记-清除，如它的名字一样，算法分为“标记”和“清除”两个阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。
此算法主要有两个缺点：一个是效率问题，标记和清除过程的效率都不高，另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片。空间碎片太多可能会导致，
当程序在以后的运行过程中，需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
2、复制算法
为了解决效率问题，一种称为“复制”的收集算法出现了，它将内存分为年轻代（1个Eden区，2个survivor区，默认比例为8：1）和年老代。一般情况下，新创建的对象都会被分配到Eden区
(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，
就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，
当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。
紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)
的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，
也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，
直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
eden 和 survior 是按8比1分配的，假如说gc后有大小为4的对象需要进入survior，survior不能保证读取全部内容，这个时候jvm应该如何处理呢？
如果Survivor To没有足够的空间，那么这些对象将会通过分配担保机制进入到老年代，分配担保机制是垃圾收集器的执行规则有关。
3标记-整理算法
此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，
第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。
4分代整理算法

垃圾收集器
Serial 串行收集器 新（复制算法） 老年代（标记整理）
用户线程与垃圾回收线程同一时刻只有一个线程运行
ParNew 并行收集器
GC线程1与GC线程2可以并行
Parallel Scavenge