快速失败与安全失败的区别：
1、快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。
	在java.util包下的都是快速失败。
2、安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。
	在java.util.concurrent包下的全是安全失败的。

hashMap与hashTable的区别
1、hashMap是实现的Map接口，hashTable是继承的Dictionary类
2、hashMap是非线程安全的，hashTable是线程安全的
3、hashMap的键和值可以是null，hashTable则不可以
4、由于线程安全的问题，hashMap的效率要比hashTable的要高

如何权衡要用无序还是有序数组
有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。 也就是说有序数组要保证插入后还是有序，所以要先找到插入的地方再进行插入，所以是O(n)，然后无序的是O(1)，有序的查询是O(logn)，而无序的是O(n).（仅做记忆）

Java中垃圾回收有什么目的？什么时候进行垃圾回收？
垃圾回收的目的是回收堆内存中不再使用的对象所占的内存，释放资源。
回收时间：即触发GC的时间，在新生代的Eden区满了，会触发新生代GC（Mimor
    GC），经过多次触发新生代GC存活下来的对象就会升级到老年代，升级到老年代的对象所需的内存大于老年代剩余的内存，则会触发老年代GC（Full
    GC）。当程序调用System.gc()时也会触发Full GC。
内存申请过程：
VM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。
当Eden区空间足够时，内存申请结束。否则执行下一步。
JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。
Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。
当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。
Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。
由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。
Scavenge GC
一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。
Full GC
对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：
1.年老代（Tenured）被写满
2.持久代（Perm）被写满
3.System.gc()被显示调用
4.上一次GC之后Heap的各域分配策略动态变化
eden 和 survior 是按8比1分配的
HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。
因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。
在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。
3.一个对象的这一辈子
我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。

如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
不会立即释放对象占用的内存。
如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，而
垃圾收集器是运行在后台的线程，只有当用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在
finalize方法中恢复引用）。只有确定了对象无法恢复引用的时候才会清除对象内存。

在Java中，对象什么时候可以被垃圾回收？
从GC Root对象开始搜索，搜索不到对象，并进行第一次标记、清理后，仍然没有复活的对象，那么这个对象可以被回收。

finally代码块和finalize()方法有什么区别？
finally作为异常处理的一部分，只能用在try/catch语句快中，finally代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。
 finalize是Object类的一个方法，该方法在Object类中声明：
        protected void finalize() throws Throwable { } 
在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的
finalize()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。

什么是JDBC？
JDBC：提供不同数据库进行统一访问的工具，使开发者可以使用Java直接操作数据库，而无需关心具体数据库的细节。

解释下驱动(Driver)在JDBC中的角色。
JDBC驱动提供了特定数据库厂商对JDBC API接口类的实现

什么是数据库连接池？
创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠。

什么是Servlet？
servlet是基于java语言的web服务器端编程技术

解释下Servlet的生命周期。
用户向服务器端发送请求，服务器端接收到请求，web服务器首先检查是否已经装载并创建了servlet对象实例，如果没有则装载并创建servlet的一个实例对象，调用servlet实例
对象的init方法，创建一个用于封装http请求消息的httpservletrequest对象和一个代表http响应消息的httpservletresponse对象，然后调用servlet的service方法并将请求和
响应对象作为参数传递进去。web应用程序停止或者重启之前，servlet引擎将卸载servlet,并在卸载之前调用servlet的destory方法。

与开放定址法相比，拉链法有如下几个优点： 
(1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； 
(2)由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； 
(3)开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； 
(4)在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 